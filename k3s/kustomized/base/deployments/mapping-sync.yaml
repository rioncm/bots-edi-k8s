apiVersion: apps/v1
kind: Deployment
metadata:
  name: bots-mappings-sync
  labels:
    app: bots-edi
    component: mappings-sync
spec:
  replicas: 1
  strategy:
    type: Recreate  # Only one sync worker should run
  selector:
    matchLabels:
      app: bots-edi
      component: mappings-sync
  template:
    metadata:
      labels:
        app: bots-edi
        component: mappings-sync
    spec:
      securityContext:
        runAsUser: 10001
        runAsGroup: 10001
        fsGroup: 10001
        fsGroupChangePolicy: "OnRootMismatch"
      
      containers:
      # Git-sync sidecar - continuously syncs repository
      - name: git-sync
        image: registry.k8s.io/git-sync/git-sync:v4.5.1
        env:
        - name: GITSYNC_REPO
          valueFrom:
            secretKeyRef:
              name: bots-mappings-git
              key: repo-url
        - name: GITSYNC_USERNAME
          valueFrom:
            secretKeyRef:
              name: bots-mappings-git
              key: username
              optional: true
        - name: GITSYNC_PASSWORD
          valueFrom:
            secretKeyRef:
              name: bots-mappings-git
              key: password
              optional: true
        - name: GITSYNC_REF
          value: "dev"  # branch/tag to sync
        - name: GITSYNC_ROOT
          value: /git
        - name: GITSYNC_LINK
          value: current  # Symlink to latest commit
        - name: GITSYNC_PERIOD
          value: "60s"  # Check for updates every 60 seconds
        - name: GITSYNC_TOUCH_FILE
          value: /signal/update  # Signal file for worker
        - name: GITSYNC_DEPTH
          value: "1"  # Shallow clone
        - name: GITSYNC_VERBOSE
          value: "2"
        - name: GITSYNC_MAX_FAILURES
          value: "3"  # Retry failed syncs
        volumeMounts:
        - name: git-data
          mountPath: /git
        - name: sync-signal
          mountPath: /signal
        resources:
          requests:
            cpu: 10m
            memory: 64Mi
          limits:
            cpu: 100m
            memory: 128Mi
      
      # Worker - watches for updates and copies to PVC
      - name: sync-worker
        image: alpine:3.19
        command: ["/bin/sh"]
        args:
        - -c
        - |
          set -e   
          
          # Target directory within PVC
          # subdirectory to prevent deletion of other files in /mappings
          TARGET_DIR="/mappings/env/${BOTSENV}/usersys/mappings/git"
          SIGNAL_FILE="/signal/update"
          
          echo "[INFO] Mappings sync worker starting..."
          echo "[INFO] Watching: ${SIGNAL_FILE}"
          echo "[INFO] Source: /git/current/"
          echo "[INFO] Target: /mappings/"
          echo "[INFO] Environment: ${BOTSENV}"

          # Function to perform sync
          sync_mappings() {
            echo "[SYNC] Update detected at $(date)"
            
            # Ensure target directory exists
            mkdir -p "${TARGET_DIR}"
            
            # Check if source has content
            if [ ! -d "/git/current" ]; then
              echo "[ERROR] Source directory /git/current not found"
              return 1
            fi
            
            # Count files to sync
            FILE_COUNT=$(find /git/current -type f -name "*.py" | wc -l)
            echo "[SYNC] Found ${FILE_COUNT} mapping files"
            
            if [ "${FILE_COUNT}" -eq 0 ]; then
              echo "[WARN] No .py files found in repository"
              # return 0
            fi
            
            # Perform atomic copy using rsync-style approach
            # Copy to temp directory first, then move
            TEMP_DIR="${TARGET_DIR}.tmp.$$"
            mkdir -p "${TEMP_DIR}"
            
            echo "[SYNC] Copying to temporary location..."
            cp -r /git/current/. "${TEMP_DIR}/"
            
            # Atomic swap
            echo "[SYNC] Performing atomic swap..."
            rm -rf "${TARGET_DIR}.old" 2>/dev/null || true
            if [ -d "${TARGET_DIR}" ]; then
              mv "${TARGET_DIR}" "${TARGET_DIR}.old"
            fi
            mv "${TEMP_DIR}" "${TARGET_DIR}"
            rm -rf "${TARGET_DIR}.old"
            
            # Set permissions
            chmod -R u+rwX,g+rX "${TARGET_DIR}"
            
            echo "[SYNC] âœ“ Sync complete at $(date)"
            echo "[SYNC] Files synced:"
            find "${TARGET_DIR}" -type f -name "*.py" | sed 's|'"${TARGET_DIR}"'/||' | sort
            echo "[SYNC] ---"
          }
          
          # Initial sync on startup
          echo "[INFO] Performing initial sync..."
          while [ ! -f "${SIGNAL_FILE}" ]; do
            echo "[INFO] Waiting for initial git-sync..."
            sleep 2
          done
          sync_mappings
          
          # Watch for updates
          echo "[INFO] Watching for updates (signal file: ${SIGNAL_FILE})"
          LAST_MTIME=$(stat -c %Y "${SIGNAL_FILE}" 2>/dev/null || echo "0")
          
          while true; do
            sleep 5
            
            if [ -f "${SIGNAL_FILE}" ]; then
              CURRENT_MTIME=$(stat -c %Y "${SIGNAL_FILE}" 2>/dev/null || echo "0")
              
              if [ "${CURRENT_MTIME}" != "${LAST_MTIME}" ]; then
                sync_mappings
                LAST_MTIME="${CURRENT_MTIME}"
              fi
            fi
          done
        envFrom:
        - configMapRef:
            name: bots-env-config
        volumeMounts:
        - name: git-data
          mountPath: /git
          readOnly: true
        - name: sync-signal
          mountPath: /signal
          readOnly: true
        - name: bots-data
          mountPath: /mappings
        resources:
          requests:
            cpu: 10m
            memory: 32Mi
          limits:
            cpu: 100m
            memory: 64Mi
      
      volumes:
      - name: git-data
        emptyDir: {}  # Git-sync writes here
      - name: sync-signal
        emptyDir: {}  # Touch file lives here
      - name: bots-data
        persistentVolumeClaim:
          claimName: bots-edi-data-pvc  # Worker writes here
      
      restartPolicy: Always
